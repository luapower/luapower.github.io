<!DOCTYPE html>
<html>
	<head>
		<meta charset='utf-8'>
		<title> objc   - Obj-C &amp; Cocoa bridge </title>
		<script src="jquery.js"></script>
		<script src="jquery-cookie.js"></script>
		<script src="jquery-tablesorter.js"></script>
		<script src="strftime.js"></script>
		<script src="config.js"></script>
		<script src="main.js"></script>
		<link rel="stylesheet" type="text/css" href="templates/reset.css" />
		<link rel="stylesheet" type="text/css" href="templates/hack.css" />
		<link rel="stylesheet" type="text/css" id="lights_css" />
		<script>
			var DOCNAME = 'objc'
			var PROJECT = 'objc'
			//set the lights before rendering starts
			set_lights()
		</script>
	</head>
	<body>
		<header>
			<div class="container">
				<div class="btn-container btn-lights-container">
					<a href="#" class="btn btn-lights" id="lights">lights</a>
				</div>
				
				<div class="btn-container btn-home-container">
					<a href="/" class="btn btn-home">luapower</a>
				</div>
				
				<table id="header_table">
					<tr>
						<td style="vertical-align: middle;" width="100%">
							<h1> objc </h1>
							<h2> Obj-C &amp; Cocoa bridge </h2>
						</td>
						<td style="vertical-align: middle;" align="right" style="height: 150px">
																						<table><tr><td>
								<div class="doc" id="package_info_container">
									<div id="package_info">&nbsp;</div>
									<div id="commit_log">&nbsp;</div>
								</div>
								<a href="https://github.com/luapower/objc" class="btn btn-rightside btn-github"><span class="icon"></span>View on GitHub</a>
								</td></tr><tr><td>
								<a href="https://github.com/luapower/objc/tarball/master" class="btn btn-rightside">Download as .tar.gz</a>
								</td></tr><tr><td>
								<a href="https://github.com/luapower/objc/zipball/master" class="btn btn-rightside">Download as .zip</a>
								</td></tr></table>
																				</td>
					</tr>
				</table>
												<div class="btn-container btn-discuss-container">
					<a href="https://github.com/luapower/objc/issues/new" target="_blank"
						class="btn btn-rightside btn-discuss"><span class="icon"></span>Discuss</a>
				</div>
											</div>
		</header>
		<div class="bg-container">
			<div class="bg-center-container">
									<div class="bg bg-objc" style="background-image: url('bg/objc.png');"></div>
							</div>
		</div>
		<div class="under-header">
			<div class="container">
				<div id="toc_container" class="toc_container doc"></div>
				<section class="doc">
					<span id="module_info"></span>
					<h2 id="local-objc-requireobjc"><code>local objc = require'objc'</code></h2>
<p>Jump To: <a href="#features">Features</a> | <a href="#quick-tutorial">Quick Tutorial</a> | <a href="#memory-management">Memory Management</a> | <a href="#main-api">Main API</a> | <a href="#reflection-api">Reflection API</a> | <a href="#debug-api">Debug API</a></p>
<h2 id="features">Features</h2>
<ul>
<li>Coverage
<ul>
<li>full access to Cocoa classes, protocols, C functions, structs, enums, constants</li>
<li>access to methods, properties and ivars</li>
<li>creating classes and overriding methods</li>
<li>exploring and searching the Objective-C runtime</li>
</ul></li>
<li>Platforms
<ul>
<li>tested with <strong>OSX 10.9</strong> (<strong>32bit</strong> and <strong>64bit</strong>)</li>
</ul></li>
<li>Dependencies
<ul>
<li>none for Cocoa (XML parser included), <a href="expat.html">expat</a> for non-standard bridgesupport files</li>
</ul></li>
<li>Type Bridging
<ul>
<li>methods and functions return Lua booleans</li>
<li>Lua numbers, strings and tables can be passed for NSNumber, NSStrings, NSArray and NSDictionary args</li>
<li>string names can be passed for class and selector args</li>
<li>Lua functions can be passed for block and function-pointer args without specifying a type signature</li>
<li>overriding methods does not require specifying the method type signature
<ul>
<li>method signatures are inferred from existing supermethods and conforming protocols
<ul>
<li>formal and informal protocols supported</li>
</ul></li>
</ul></li>
<li>function-pointer args on overriden methods and blocks can be called without specifying a type signature</li>
</ul></li>
<li>GC Bridging
<ul>
<li>attaching Lua variables to classes and objects
<ul>
<li>Lua variables follow the lifetime of Obj-C objects</li>
<li>Lua variables attached to classes are inherited</li>
</ul></li>
<li>automatic memory management of objects and blocks
<ul>
<li>blocks are refcounted and freed when their last owner releases them</li>
</ul></li>
</ul></li>
<li>Speed
<ul>
<li>aggressive caching all-around</li>
<li>no gc pressure in calling methods after the first invocation</li>
<li>fast, small embedded XML parser</li>
</ul></li>
</ul>
<h2 id="limitations">Limitations</h2>
<ul>
<li>blocks, function callbacks and overriden methods are based on ffi callbacks which come with some limitations:
<ul>
<li>can't access the vararg part of the function, for variadic functions/methods</li>
<li>can't access the pass-by-value struct args or any arg after the first pass-by-value struct arg</li>
<li>can't return structs by value</li>
<li><strong>UPDATE</strong>: you can use <a href="cbframe.html">cbframe</a> as a workaround. Enable it with <code>objc.debug.cbframe = true</code>; now all the problem methods and blocks will receive a single arg: a pointer to a <a href="https://github.com/luapower/cbframe/blob/master/cbframe_x86_h.lua">D_CPUSTATE</a> struct that you have to pick up args from and set return value into (note: self isn't passed, the cpu state is the only arg).</li>
</ul></li>
</ul>
<h2 id="quick-tutorial">Quick Tutorial</h2>
<h3 id="loading-frameworks">Loading frameworks</h3>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="co">--load a framework by name; `objc.searchpaths` says where the frameworks are. you can also use full paths.</span>
<span class="co">--classes and protocols are loaded, but also C constants, enums, functions, structs and even macros.</span>
<span class="kw">objc</span><span class="ot">.</span>load<span class="st">&#39;Foundation&#39;</span>

<span class="co">--you can also load sub-frameworks like this:</span>
<span class="kw">objc</span><span class="ot">.</span>load<span class="st">&#39;Carbon.HIToolbox&#39;</span>

<span class="co">--which is the same as using relative paths:</span>
<span class="kw">objc</span><span class="ot">.</span>load<span class="st">&#39;Carbon.framework/Versions/Current/Frameworks/HIToolbox&#39;</span></code></pre>
<h3 id="creating-and-using-objects">Creating and using objects</h3>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="co">--instantiate a class. the resulting object is retained and released on gc.</span>
<span class="co">--you can call `release()` on it too, for a more speedy destruction.</span>
<span class="kw">local</span> <span class="kw">str</span> <span class="ot">=</span> <span class="kw">objc</span><span class="ot">.</span><span class="kw">NSString</span>:alloc<span class="ot">()</span>:initWithUTF8String<span class="st">&#39;wazza&#39;</span>

<span class="co">--call methods with multiple arguments using underscores for &#39;:&#39;. last underscore is optional.</span>
<span class="co">--C constants, enums and functions are in the objc namespace too.</span>
<span class="kw">local</span> <span class="kw">result</span> <span class="ot">=</span> <span class="kw">str</span>:compare_options<span class="ot">(</span><span class="kw">otherStr</span><span class="ot">,</span> <span class="kw">objc</span><span class="ot">.</span><span class="kw">NSLiteralSearch</span><span class="ot">)</span></code></pre>
<h3 id="subclassing">Subclassing</h3>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="co">--create a derived class. when creating a class, say which protocols you wish it conforms to,</span>
<span class="co">--so that you don&#39;t have to deal with type encodings when implementing its methods.</span>
<span class="kw">objc</span><span class="ot">.</span>class<span class="ot">(</span><span class="st">&#39;NSMainWindow&#39;</span><span class="ot">,</span> <span class="st">&#39;NSWindw &lt;NSWindowDelegate&gt;&#39;</span><span class="ot">)</span>

<span class="co">--add methods to your class. the selector `windowWillClose` is from the `NSWindowDelegate` protocol</span>
<span class="co">--so its type encoding is inferred from the protocol definition.</span>
<span class="kw">function</span> <span class="kw">objc</span><span class="ot">.</span><span class="kw">NSMainWindow</span>:windowWillClose<span class="ot">(</span><span class="kw">notification</span><span class="ot">)</span>
   <span class="ot">...</span>
<span class="kw">end</span>

<span class="co">--override existing methods. use `objc.callsuper` to call the supermethod.</span>
<span class="kw">function</span> <span class="kw">objc</span><span class="ot">.</span><span class="kw">NSMainWindow</span>:update<span class="ot">()</span>
   <span class="ot">...</span>
   <span class="kw">return</span> <span class="kw">objc</span><span class="ot">.</span>callsuper<span class="ot">(</span><span class="kw">self</span><span class="ot">,</span> <span class="st">&#39;update&#39;</span><span class="ot">)</span>
<span class="kw">end</span></code></pre>
<h3 id="converting-between-lua-and-obj-c-types">Converting between Lua and Obj-C types</h3>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">local</span> <span class="kw">str</span> <span class="ot">=</span> <span class="kw">objc</span><span class="ot">.</span>toobj<span class="st">&#39;hello&#39;</span>             <span class="co">--create a NSString from a Lua string</span>
<span class="kw">local</span> <span class="kw">num</span> <span class="ot">=</span> <span class="kw">objc</span><span class="ot">.</span>toobj<span class="ot">(</span><span class="dv">3.14</span><span class="ot">)</span>              <span class="co">--create a NSNumber from a Lua number</span>
<span class="kw">local</span> <span class="kw">dic</span> <span class="ot">=</span> <span class="kw">objc</span><span class="ot">.</span>toobj<span class="ot">{</span><span class="kw">a</span> <span class="ot">=</span> <span class="dv">1</span><span class="ot">,</span> <span class="kw">b</span> <span class="ot">=</span> <span class="st">&#39;hi&#39;</span><span class="ot">}</span>   <span class="co">--create a NSDictionary from a Lua table</span>
<span class="kw">local</span> <span class="kw">arr</span> <span class="ot">=</span> <span class="kw">objc</span><span class="ot">.</span>toobj<span class="ot">{</span><span class="dv">1</span><span class="ot">,</span> <span class="dv">2</span><span class="ot">,</span> <span class="dv">3</span><span class="ot">}</span>           <span class="co">--create a NSArray from a Lua table</span>

<span class="kw">local</span> <span class="kw">s</span> <span class="ot">=</span> <span class="kw">objc</span><span class="ot">.</span>tolua<span class="ot">(</span><span class="kw">str</span><span class="ot">)</span>
<span class="kw">local</span> <span class="kw">n</span> <span class="ot">=</span> <span class="kw">objc</span><span class="ot">.</span>tolua<span class="ot">(</span><span class="kw">num</span><span class="ot">)</span>
<span class="kw">local</span> <span class="kw">t1</span> <span class="ot">=</span> <span class="kw">objc</span><span class="ot">.</span>tolua<span class="ot">(</span><span class="kw">dic</span><span class="ot">)</span>
<span class="kw">local</span> <span class="kw">t2</span> <span class="ot">=</span> <span class="kw">objc</span><span class="ot">.</span>tolua<span class="ot">(</span><span class="kw">arr</span><span class="ot">)</span></code></pre>
<h3 id="adding-lua-variables-luavars">Adding Lua variables (luavars)</h3>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="co">--add Lua variables to your objects - their lifetime is tied to the lifetime of the object.</span>
<span class="co">--you can also add class variables - they will be accessible through the objects too.</span>
<span class="kw">objc</span><span class="ot">.</span><span class="kw">NSObject</span><span class="ot">.</span><span class="kw">myClassVar</span> <span class="ot">=</span> <span class="st">&#39;I can live forever&#39;</span>
<span class="kw">local</span> <span class="kw">obj</span> <span class="ot">=</span> <span class="kw">objc</span><span class="ot">.</span><span class="kw">NSObject</span>:new<span class="ot">()</span>
<span class="kw">obj</span><span class="ot">.</span><span class="kw">myInstanceVar</span> <span class="ot">=</span> <span class="st">&#39;I live while obj lives&#39;</span>
<span class="kw">obj</span><span class="ot">.</span><span class="kw">myClassVar</span> <span class="ot">=</span> <span class="dv">5</span> <span class="co">--change the class var (same value for all objects)</span></code></pre>
<h3 id="adding-lua-methods">Adding Lua methods</h3>
<p>Lua methods are just Lua variables which happen to have a function-type value. You can add them to a class or to an instance, but that doesn't make them &quot;class methods&quot; or &quot;instance methods&quot; in OOP sense. Instead, this distinction comes about when you call them:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">function</span> <span class="kw">objc</span><span class="ot">.</span><span class="kw">NSObject</span>:myMethod<span class="ot">()</span> <span class="kw">end</span>
<span class="kw">local</span> <span class="kw">str</span> <span class="ot">=</span> <span class="kw">objc</span><span class="ot">.</span>toobj<span class="st">&#39;hello&#39;</span>   <span class="co">--create a NSString instance, which is a NSObject</span>
<span class="kw">str</span>:myMethod<span class="ot">()</span>                  <span class="co">--instance method (str passed as self)</span>
<span class="kw">objc</span><span class="ot">.</span><span class="kw">NSString</span>:myMethod<span class="ot">()</span>        <span class="co">--class method (NSString passed as self)</span></code></pre>
<p>As you can see, luavars attached to a class are also inherited.</p>
<blockquote>
<p>If this looks like a lot of magic, it is. The indexing rules for class and instance objects (i.e. getting and setting object and class fields) are pretty complex. Have a look at the API sections &quot;object fields&quot; and &quot;class fields&quot; to learn more.</p>
</blockquote>
<h3 id="accessing-properties-ivars">Accessing properties &amp; ivars</h3>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="co">--get and set class and instance properties using the dot notation.</span>
<span class="kw">local</span> <span class="kw">pr</span> <span class="ot">=</span> <span class="kw">objc</span><span class="ot">.</span><span class="kw">NSProgress</span>:progressWithTotalUnitCount<span class="ot">(</span><span class="dv">123</span><span class="ot">)</span>
<span class="fu">print</span><span class="ot">(</span><span class="kw">pr</span><span class="ot">.</span><span class="kw">totalUnitCount</span><span class="ot">)</span> <span class="co">--prints 123</span>
<span class="kw">pr</span><span class="ot">.</span><span class="kw">totalUnitCount</span> <span class="ot">=</span> <span class="dv">321</span>  <span class="co">--sets it</span>

<span class="co">--get and set ivars using the dot notation.</span>
<span class="kw">local</span> <span class="kw">obj</span> <span class="ot">=</span> <span class="kw">objc</span><span class="ot">.</span><span class="kw">NSDocInfo</span>:new<span class="ot">()</span>
<span class="kw">obj</span><span class="ot">.</span><span class="kw">time</span> <span class="ot">=</span> <span class="dv">123</span>
<span class="fu">print</span><span class="ot">(</span><span class="kw">obj</span><span class="ot">.</span><span class="kw">time</span><span class="ot">)</span> <span class="co">--prints 123</span></code></pre>
<h3 id="creating-and-using-blocks">Creating and using blocks</h3>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="co">--blocks are created automatically when passing a Lua function where a block is expected.</span>
<span class="co">--their lifetime is auto-managed, for both synchronous and asynchronous methods.</span>
<span class="kw">local</span> <span class="kw">str</span> <span class="ot">=</span> <span class="kw">objc</span><span class="ot">.</span><span class="kw">NSString</span>:alloc<span class="ot">()</span>:initWithUTF8String<span class="st">&#39;line1</span><span class="ot">\n</span><span class="st">line2</span><span class="ot">\n</span><span class="st">line3&#39;</span>
<span class="kw">str</span>:enumerateLinesUsingBlock<span class="ot">(</span><span class="kw">function</span><span class="ot">(</span><span class="kw">line</span><span class="ot">,</span> <span class="kw">stop</span><span class="ot">)</span>
   <span class="fu">print</span><span class="ot">(</span><span class="kw">line</span>:UTF8String<span class="ot">())</span> <span class="co">--&#39;char *&#39; return values are also converted to Lua strings automatically</span>
<span class="kw">end</span><span class="ot">)</span>

<span class="co">--however, blocks are slow to create and use ffi callbacks which are very limited in number.</span>
<span class="co">--create your blocks outside loops if possible, or call `collectgarbage()` every few hundred iterations.</span>

<span class="co">--create a block with its type signature inferred from usage.</span>
<span class="co">--in this case, its type is that of arg#1 to NSString&#39;s `enumerateLinesUsingBlock` method.</span>
<span class="kw">local</span> <span class="kw">block</span> <span class="ot">=</span> <span class="kw">objc</span><span class="ot">.</span>toarg<span class="ot">(</span><span class="kw">objc</span><span class="ot">.</span><span class="kw">NSString</span><span class="ot">,</span> <span class="st">&#39;enumerateLinesUsingBlock&#39;</span><span class="ot">,</span> <span class="dv">1</span><span class="ot">,</span> <span class="kw">function</span><span class="ot">(</span><span class="kw">line</span><span class="ot">,</span> <span class="kw">stop</span><span class="ot">)</span>
   <span class="fu">print</span><span class="ot">(</span><span class="kw">line</span>:UTF8String<span class="ot">())</span>
<span class="kw">end</span><span class="ot">)</span>
<span class="kw">str</span>:enumerateLinesUsingBlock<span class="ot">(</span><span class="kw">block</span><span class="ot">)</span>

<span class="co">--create a block with its method type encoding given manaully.</span>
<span class="co">--for type encodings see:</span>
<span class="co">--   https://code.google.com/p/jscocoa/wiki/MethodEncoding</span>
<span class="co">--   https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html</span>
<span class="kw">local</span> <span class="kw">block</span> <span class="ot">=</span> <span class="kw">objc</span><span class="ot">.</span>block<span class="ot">(</span><span class="kw">function</span><span class="ot">(</span><span class="kw">line</span><span class="ot">,</span> <span class="kw">stop</span><span class="ot">)</span>
   <span class="fu">print</span><span class="ot">(</span><span class="kw">line</span>:UTF8String<span class="ot">())</span>
<span class="kw">end</span><span class="ot">,</span> <span class="st">&#39;v@^B&#39;</span><span class="ot">})</span> <span class="co">--retval is &#39;v&#39; (void), line is &#39;@&#39; (object), stop is &#39;^B&#39; (pointer to BOOL)</span>
<span class="kw">str</span>:enumerateLinesUsingBlock<span class="ot">(</span><span class="kw">block</span><span class="ot">)</span></code></pre>
<h3 id="more-goodies">More goodies</h3>
<p>Look up anything in Cocoa by a Lua pattern:</p>
<pre><code>   ./luajit objc_test.lua inspect_find foo</code></pre>
<p>Then inspect it:</p>
<pre><code>   ./luajit objc_test.lua inspect_class PAFootprint</code></pre>
<h3 id="even-more-goodies">Even more goodies</h3>
<p>Check out the unit test script, it also contains a few demos, not just tests.<br />Check out the undocumented <code>objc_inspect</code> module, it has a simple cmdline inspection API.</p>
<h2 id="memory-management">Memory management</h2>
<p>Memory management in objc is automatic. Cocoa's reference counting system is tied to the Lua's garbage collector so that you don't have to worry about retain/release. The integration is not air-tight though, so you need to know how it's put together to avoid some tricky situations.</p>
<h3 id="strong-and-weak-references">Strong and weak references</h3>
<p>Ref. counting systems are fragile: they require that retain() and release() calls on an object be perfectly balanced. If they're not, you're toast. Thinking of object relationships in in terms of weak and strong references can help a lot with that.</p>
<p>A strong reference is a retained reference, guaranteed to be available until released. A weak reference is not retained and its availability depends on context.</p>
<p>A strong reference has a finalizer that calls release() when collected. A weak reference doesn't have a finalizer.</p>
<p>Calling release() on a strong reference releases the reference, and removes the finalizer, turning it into a weak reference. You should not call release() on a weak reference.</p>
<h3 id="return-values-are-strong">Return values are strong</h3>
<p>Cocoa's rules say that if you alloc an object, you get a strong (retained) reference on that object. Other method calls that return an object return a weak (non-retained) reference to that object. Lua retains all object return values so you always get a strong reference. This is required for the alloc():init() sequence to work, and it's generally convenient.</p>
<h3 id="callback-arguments-are-weak">Callback arguments are weak</h3>
<p>Object arguments passed to overriden methods (including the self argument), blocks and function pointers, are weak references, not tied to Lua's garbage collector. If you want to keep them around outside the scope of the callback, you need to retain them:</p>
<pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">local</span> <span class="kw">strong_ref</span>
<span class="kw">function</span> <span class="kw">MySubClass</span>:overridenMethod<span class="ot">()</span>
   <span class="kw">strong_ref</span> <span class="ot">=</span> <span class="kw">self</span>:retain<span class="ot">()</span> <span class="co">--self is a weak ref. it needs to be retained.</span>
<span class="kw">end</span></code></pre>
<h3 id="luavars-and-object-ownership">Luavars and object ownership</h3>
<p>You should only use luavars on objects that you own. Luavars go away when the last strong reference to an object goes away. Setting Lua vars on an object with only weak references will leak those vars! Even worse, those vars might show up as vars of other objects!</p>
<h3 id="strongweak-ambiguities">Strong/weak ambiguities</h3>
<p>If you create a <code>NSWindow</code>, you don't get an <em>unconditionally</em> retained reference to that window, contrary to Cocoa's rules, because if the user closes the window, it is your reference that gets released. The binding doesn't know about that and on gc it calls release again, giving you a crash at an unpredictable time (<code>export NSZombieEnabled=YES</code> can help here). To fix that you can either tell Cocoa that your ref is strong by calling <code>win:setReleasedWhenClosed(false)</code>, or tell the gc that your ref is weak by calling <code>ffi.gc(win, nil)</code>. If you chose the latter, remember that you can't use luavars on that window!</p>
<h2 id="main-api">Main API</h2>
<table>
<col width="49%" />
<col width="50%" />
<tbody>
<tr class="odd">
<td align="left"><strong>global objects</strong></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>objc</code></td>
<td align="left">namespace for loaded classes, C functions, function aliases, enums, constants, and this API</td>
</tr>
<tr class="odd">
<td align="left"><strong>frameworks</strong></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>objc.load(name|path[, option])</code></td>
<td align="left">load a framework given its name or its full path<br />option 'notypes': don't load bridgesupport file</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.searchpaths = {path1, ...}</code></td>
<td align="left">search paths for frameworks</td>
</tr>
<tr class="even">
<td align="left"><code>objc.findframework(name|path) -&gt; path, name</code></td>
<td align="left">find a framework in searchpaths</td>
</tr>
<tr class="odd">
<td align="left"><strong>classes</strong></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>objc.class'name' -&gt; cls</code></td>
<td align="left">class by name (<code>objc.class'Foo'</code> == <code>objc.Foo</code>)</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.class(obj) -&gt; cls</code></td>
<td align="left">class of instance</td>
</tr>
<tr class="even">
<td align="left"><code>objc.class('Foo', 'SuperFoo &lt;Protocol1, ...&gt;') -&gt; cls</code></td>
<td align="left">create a class which conforms to protocols</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.class('Foo', 'SuperFoo', 'Protocol1', ...) -&gt; cls</code></td>
<td align="left">create a class (alternative way)</td>
</tr>
<tr class="even">
<td align="left"><code>objc.classname(cls) -&gt; s</code></td>
<td align="left">class name</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.isclass(x) -&gt; true|false</code></td>
<td align="left">check for Class type</td>
</tr>
<tr class="even">
<td align="left"><code>objc.isobj(x) -&gt; true|false</code></td>
<td align="left">check for id type</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.ismetaclass(cls) -&gt; true|false</code></td>
<td align="left">check if the class is a metaclass</td>
</tr>
<tr class="even">
<td align="left"><code>objc.superclass(cls|obj) -&gt; cls|nil</code></td>
<td align="left">superclass</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.metaclass(cls|obj) -&gt; cls</code></td>
<td align="left">metaclass</td>
</tr>
<tr class="even">
<td align="left"><code>objc.isa(cls|obj, supercls) -&gt; true|false</code></td>
<td align="left">check the inheritance chain</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.conforms(cls|obj, protocol) -&gt; true|false</code></td>
<td align="left">check if a class conforms to a protocol</td>
</tr>
<tr class="even">
<td align="left"><code>objc.responds(cls, sel) -&gt; true|false</code></td>
<td align="left">check if instances of cls responds to a selector</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.conform(cls, protocol) -&gt; true|false</code></td>
<td align="left">declare that a class conforms to a protocol</td>
</tr>
<tr class="even">
<td align="left"><strong>object fields</strong></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>obj.field</code><br /><code>obj:method(args...)</code></td>
<td align="left">access an instance field, i.e. try to get, in order:<br />- an instance luavar<br />- a readable instance property<br />- an ivar<br />- an instance method<br />- a class field (see below)</td>
</tr>
<tr class="even">
<td align="left"><code>obj.field = val</code><br /></td>
<td align="left">set an instance field, i.e. try to set, in order:<br />- an existing instance luavar<br />- a writable instance property<br />- an ivar<br />- an existing class field (see below)<br />- a new instance luavar</td>
</tr>
<tr class="odd">
<td align="left"><strong>class fields</strong></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>cls.field</code><br /><code>cls:method(args...)</code></td>
<td align="left">access a class field, i.e. try to get, in order:<br />- a class luavar<br />- a readable class property<br />- a class method<br />- a class luavar from a superclass</td>
</tr>
<tr class="odd">
<td align="left"><code>cls.field = val</code><br /><code>function cls:method(args...) end</code></td>
<td align="left">set a class field, i.e. try to set, in order:<br />- an existing class luavar<br />- a writable class property<br />- an instance method<br />- a conforming instance method<br />- a class method<br />- a conforming class method<br />- an existing class luavar in a superclass<br />- a new class luavar</td>
</tr>
<tr class="even">
<td align="left"><strong>type conversions</strong></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>objc.tolua(x) -&gt; luatype</code></td>
<td align="left">convert a NSNumber, NSString, NSDictionary, NSArray to a Lua number, string, table respectively. anything else passes through.</td>
</tr>
<tr class="even">
<td align="left"><code>objc.toobj(x) -&gt; objtype</code></td>
<td align="left">convert a Lua number, string, or table to a NSNumber, NSString, NSDictionary, NSArray respectively. anything else passes through.</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.ipairs(arr) -&gt; next, arr, 0</code></td>
<td align="left">ipairs for NSarray.</td>
</tr>
<tr class="even">
<td align="left"><strong>overriding</strong></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>objc.override(cls, sel, func[,mtype|ftype]) -&gt; true|false</code></td>
<td align="left">override an existing method, or add a method which conforms to one of the conforming protocols. returns true if the method was found and overriden.</td>
</tr>
<tr class="even">
<td align="left"><code>objc.callsuper(obj, sel, args...) -&gt; retval</code></td>
<td align="left">call the method implementation of the superclass of an object.</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.swizle(cls, sel1, sel2[, func])</code></td>
<td align="left">swap implementations between sel1 and sel2. if sel2 is not an existing selector, func is required.</td>
</tr>
<tr class="even">
<td align="left"><strong>selectors</strong></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>objc.SEL(name|sel) -&gt; sel</code></td>
<td align="left">create/find a selector by name</td>
</tr>
<tr class="even">
<td align="left"><code>sel:name() -&gt; s</code></td>
<td align="left">selector name (same as tostring(sel))</td>
</tr>
<tr class="odd">
<td align="left"><strong>blocks and callbacks</strong></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>objc.toarg(cls, sel, argindex, x) -&gt; objtype</code></td>
<td align="left">convert a Lua value to an objc value - used specifically to create blocks and function callbacks with an appropriate type signature for a specific method argument.</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.block(func, mtype|ftype) -&gt; block</code></td>
<td align="left">create a block with a specific type encoding.</td>
</tr>
</tbody>
</table>
<h2 id="reflection-api">Reflection API</h2>
<table>
<col width="49%" />
<col width="50%" />
<tbody>
<tr class="odd">
<td align="left"><strong>protocols</strong></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>objc.protocols() -&gt; iter() -&gt; proto</code></td>
<td align="left">loaded protocols (formal or informal)</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.protocol(name|proto) -&gt; proto</code></td>
<td align="left">get a protocol by name (formal or informal)</td>
</tr>
<tr class="even">
<td align="left"><code>proto:name() -&gt; s</code></td>
<td align="left">protocol name (same as tostring(proto))</td>
</tr>
<tr class="odd">
<td align="left"><code>proto:protocols() -&gt; iter() -&gt; proto</code></td>
<td align="left">inherited protocols</td>
</tr>
<tr class="even">
<td align="left"><code>proto:properties() -&gt; iter() -&gt; prop</code></td>
<td align="left">get properties (inherited ones not included)</td>
</tr>
<tr class="odd">
<td align="left"><code>proto:property(proto, name, required, readonly) -&gt; prop</code></td>
<td align="left">find a property</td>
</tr>
<tr class="even">
<td align="left"><code>proto:methods(proto, inst, req) -&gt; iter() -&gt; sel, mtype</code></td>
<td align="left">get method names and raw, non-annotated type encodings</td>
</tr>
<tr class="odd">
<td align="left"><code>proto:mtype(proto, sel, inst, req) -&gt; mtype</code></td>
<td align="left">find a method and return its raw type encoding</td>
</tr>
<tr class="even">
<td align="left"><code>proto:ctype(proto, sel, inst, req[, for_cb]) -&gt; ctype</code></td>
<td align="left">find a method and return its C type encoding</td>
</tr>
<tr class="odd">
<td align="left"><strong>classes</strong></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>objc.classes() -&gt; iter() -&gt; cls</code></td>
<td align="left">loaded classes</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.protocols(cls) -&gt; iter() -&gt; proto</code></td>
<td align="left">protocols which a class conforms to (formal or informal)</td>
</tr>
<tr class="even">
<td align="left">objc.properties(cls) -&gt; iter() -&gt; prop`</td>
<td align="left">instance properties<br />use metaclass(cls) to get class properties</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.property(cls, name) -&gt; prop</code></td>
<td align="left">instance property by name (looks in superclasses too)</td>
</tr>
<tr class="even">
<td align="left"><code>objc.methods(cls) -&gt; iter() -&gt; meth</code></td>
<td align="left">instance methods<br />use metaclass(cls) to get class methods</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.method(cls, name) -&gt; meth</code></td>
<td align="left">instance method by name (looks in superclasses too)</td>
</tr>
<tr class="even">
<td align="left"><code>objc.ivars(cls) -&gt; iter() -&gt; ivar</code></td>
<td align="left">ivars</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.ivar(cls) -&gt; ivar</code></td>
<td align="left">ivar by name (looks in superclasses too)</td>
</tr>
<tr class="even">
<td align="left"><strong>properties</strong></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>prop:name() -&gt; s</code></td>
<td align="left">property name (same as tostring(prop))</td>
</tr>
<tr class="even">
<td align="left"><code>prop:getter() -&gt; s</code></td>
<td align="left">getter name</td>
</tr>
<tr class="odd">
<td align="left"><code>prop:setter() -&gt; s</code></td>
<td align="left">setter name (if not readonly)</td>
</tr>
<tr class="even">
<td align="left"><code>prop:stype() -&gt; s</code></td>
<td align="left">type encoding</td>
</tr>
<tr class="odd">
<td align="left"><code>prop:ctype() -&gt; s</code></td>
<td align="left">C type encoding</td>
</tr>
<tr class="even">
<td align="left"><code>prop:readonly() -&gt; true|false</code></td>
<td align="left">readonly check</td>
</tr>
<tr class="odd">
<td align="left"><code>prop:ivar() -&gt; s</code></td>
<td align="left">ivar name</td>
</tr>
<tr class="even">
<td align="left"><strong>methods</strong></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>meth:selector() -&gt; sel</code></td>
<td align="left">selector</td>
</tr>
<tr class="even">
<td align="left"><code>meth:name() -&gt; s</code></td>
<td align="left">selector name (same as tostring(meth))</td>
</tr>
<tr class="odd">
<td align="left"><code>meth:mtype() -&gt; s</code></td>
<td align="left">type encoding</td>
</tr>
<tr class="even">
<td align="left"><code>meth:implementation() -&gt; IMP</code></td>
<td align="left">implementation (untyped)</td>
</tr>
<tr class="odd">
<td align="left"><strong>ivars</strong></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>ivar:name() -&gt; s</code></td>
<td align="left">name (same as tostring(ivar))</td>
</tr>
<tr class="odd">
<td align="left"><code>ivar:stype() -&gt; s</code></td>
<td align="left">type encoding</td>
</tr>
<tr class="even">
<td align="left"><code>ivar:ctype() -&gt; s</code></td>
<td align="left">C type encoding</td>
</tr>
<tr class="odd">
<td align="left"><code>ivar:offset() -&gt; n</code></td>
<td align="left">offset</td>
</tr>
</tbody>
</table>
<h2 id="debug-api">Debug API</h2>
<table>
<tbody>
<tr class="odd">
<td align="left"><strong>logging</strong></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>objc.debug.errors</code> (true)</td>
<td align="left">log errors to stderr</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.debug.printcdecl</code> (false)</td>
<td align="left">print C declarations on stdout</td>
</tr>
<tr class="even">
<td align="left"><code>objc.debug.logtopics= {topic = true}</code> (empty)</td>
<td align="left">enable logging on some topic (see source code)</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.debug.errcount = {topic = count}</code></td>
<td align="left">error counts</td>
</tr>
<tr class="even">
<td align="left"><strong>solving C name clashes</strong></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>objc.debug.rename.string.foo = bar</code></td>
<td align="left">load a string constant under a different name</td>
</tr>
<tr class="even">
<td align="left"><code>objc.debug.rename.enum.foo = bar</code></td>
<td align="left">load an enum under a different name</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.debug.rename.typedef.foo = bar</code></td>
<td align="left">load a type under a different name</td>
</tr>
<tr class="even">
<td align="left"><code>objc.debug.rename.const.foo = bar</code></td>
<td align="left">load a const under a different name</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.debug.rename.function.foo = bar</code></td>
<td align="left">load a global function under a different name</td>
</tr>
<tr class="even">
<td align="left"><strong>loading frameworks</strong></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>objc.debug.loadtypes</code> (true)</td>
<td align="left">load bridgesupport files</td>
</tr>
<tr class="even">
<td align="left"><code>objc.debug.loaddeps</code> (false)</td>
<td align="left">load dependencies per bridgesupport file (too many to be useful)</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.debug.lazyfuncs</code> (true)</td>
<td align="left">cdef functions on the first call instead of on load</td>
</tr>
<tr class="even">
<td align="left"><code>objc.debug.checkredef</code> (false)</td>
<td align="left">check incompatible redefinition attempts (makes parsing slower)</td>
</tr>
<tr class="odd">
<td align="left"><code>objc.debug.usexpat</code> (false)</td>
<td align="left">use expat to parse bridgesupport files</td>
</tr>
<tr class="even">
<td align="left"><strong>gc bridging</strong></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>objc.debug.noretain.foo = true</code></td>
<td align="left">declare that method <code>foo</code> already retains the object it returns</td>
</tr>
</tbody>
</table>
<h2 id="credits">Credits</h2>
<ul>
<li>Cosmin Apreutesei, May 2014, public domain.</li>
<li>Ideas and code from <a href="https://github.com/fjolnir/TLC">TLC</a> by Fjölnir Ásgeirsson (c) 2012, MIT license.</li>
</ul>
<h2 id="future-developments">Future developments</h2>
<blockquote>
<p>NOTE: I don't plan to work on these, except on requests with a use case. Patches/pull requests welcome.</p>
</blockquote>
<h3 id="bridging">Bridging</h3>
<ul>
<li>function-pointer args on function-pointer args (recorded but not used - need use cases)</li>
<li>test for overriding a method that takes a function-pointer (not a block) arg and invoking that arg from the callback</li>
<li>auto-coercion of types for functions/methods with format strings, eg. NSLog
<ul>
<li>format string parser - apply to variadic functions and methods that have the <code>printf_format</code> attribute</li>
</ul></li>
<li>return pass-by-reference out parameters as multiple Lua return values
<ul>
<li>record type modifiers O=out, N=inout</li>
</ul></li>
<li>auto-allocation of out arrays using array type annotations
<ul>
<li><code>c_array_length_in_result</code> - array length is the return value</li>
<li><code>c_array_length_in_arg</code> - array length is an arg</li>
<li><code>c_array_delimited_by_null</code> - vararg ends in null - doesn't luajit do that already?</li>
<li><code>c_array_of_variable_length</code> - ???</li>
<li><code>c_array_of_fixed_length</code> - specifies array size? doesn't seem so</li>
</ul></li>
<li><code>sel_of_type</code>, <code>sel_of_type64</code> - use cases?</li>
<li>core foundation stuff
<ul>
<li><code>cftypes</code> xml node - use cases?</li>
<li><code>already_retained</code> flag</li>
</ul></li>
<li>operator overloading (need good use cases)</li>
</ul>
<h3 id="inspection">Inspection</h3>
<ul>
<li>list all frameworks in searchpaths</li>
<li>find framework in searchpaths</li>
<li>report conforming methods, where they come from and mark the required ones, especially required but not implemented</li>
<li>inspection of instances
<ul>
<li>print class, superclasses and protocols in one line</li>
<li>print values of luavars, ivars, properties</li>
<li>listing sections: ivars, properties, methods, with origin class/protocol for each</li>
</ul></li>
</ul>
<h3 id="type-cache">Type Cache</h3>
<p>The idea is to cache bridgesupport data into Lua files for faster loading of frameworks.</p>
<ul>
<li>one Lua cache file for each framework to be loaded with standard 'require'
<ul>
<li>dependencies also loaded using standard 'require'</li>
</ul></li>
<li>save dependency loading</li>
<li>save cdecls - there's already a pretty printer and infrastructure for recording those</li>
<li>save constants and enums</li>
<li>save function wrappers</li>
<li>save mtas (find a more compact format for annotations containing only {retval='B'} ?)</li>
<li>save informal protocols</li>
</ul>
				</section>
			</div>
			<div class="container">
				<footer>
					<div id="disqus_thread"></div>
					<div class="faint">cosmin.apreutesei@gmail.com | <a href="http://unlicense.org/">public domain</a></div>
				</footer>
			</div>
		</div>
	</body>
</html>

